{
  "name": "Knowledge Base Sync",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "kb/sync",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [-720, 16],
      "id": "webhook-kb-sync",
      "name": "Webhook",
      "webhookId": "kb-sync-webhook-id"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [1920, 16],
      "id": "respond-webhook",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "jsCode": "// Parse and validate webhook input\nconst webhookData = $input.first().json;\nconst body = webhookData.body || webhookData;\n\n// Validate input\nif (!body.action || !['create', 'update', 'delete'].includes(body.action)) {\n  throw new Error('Invalid action. Must be create, update, or delete');\n}\n\nif (!body.kbItemId) {\n  throw new Error('Missing kbItemId');\n}\n\n// Return formatted data\nreturn {\n  json: {\n    action: body.action,\n    kbItemId: body.kbItemId,\n    trigger: body.trigger || 'webhook'\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-480, 16],
      "id": "parse-input",
      "name": "Parse Input"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-1",
              "leftValue": "={{ $json.action }}",
              "rightValue": "delete",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [-240, 16],
      "id": "check-action",
      "name": "Check Action"
    },
    {
      "parameters": {
        "operation": "deleteOne",
        "collection": "knowledge_base_vectors",
        "filter": {
          "_id": "={{ $('Parse Input').first().json.kbItemId }}"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.mongodb",
      "typeVersion": 1.2,
      "position": [0, -80],
      "id": "delete-vector",
      "name": "Delete from Vector DB",
      "credentials": {
        "mongoDb": {
          "id": "mongodb-credentials",
          "name": "MongoDB Vector DB"
        }
      }
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $env.PAYLOAD_API_URL }}/api/knowledge-base-items/{{ $('Parse Input').first().json.kbItemId }}/api-key",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{ $env.PAYLOAD_KEY }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [0, 80],
      "id": "fetch-kb-item",
      "name": "Fetch KB Item from Payload"
    },
    {
      "parameters": {
        "jsCode": "// Check if item should be synced\n// Get KB item from previous node (Fetch KB Item from Payload)\nconst kbItem = $('Fetch KB Item from Payload').first().json;\n\n// Get existing vector from MongoDB check\nconst existingVector = $input.first().json || null;\n\n// Only sync published items\nif (kbItem.status !== 'published') {\n  return {\n    json: {\n      shouldSync: false,\n      reason: 'Item is not published',\n      kbItem: kbItem\n    }\n  };\n}\n\nif (!existingVector) {\n  // Item doesn't exist - needs sync\n  return {\n    json: {\n      shouldSync: true,\n      reason: 'Item not found in vector DB',\n      kbItem: kbItem,\n      needsEmbedding: true\n    }\n  };\n}\n\n// Item exists - check if content changed\n// Create content hash for comparison\nfunction createContentHash(item) {\n  const title = item.title_de || '';\n  const content = JSON.stringify(item.content_de || {});\n  const tags = JSON.stringify((item.tags || []).map(t => t.tag || t).sort());\n  const category = item.category || '';\n  return `${title}|${content}|${tags}|${category}`;\n}\n\nconst currentHash = createContentHash(kbItem);\nconst existingHash = createContentHash(existingVector);\n\nif (currentHash !== existingHash) {\n  // Content changed - needs sync\n  return {\n    json: {\n      shouldSync: true,\n      reason: 'Content changed',\n      kbItem: kbItem,\n      needsEmbedding: true\n    }\n  };\n}\n\n// Check if embedding model changed\nconst currentModel = $env.EMBEDDING_MODEL || 'text-embedding-3-small';\nif (existingVector.embeddingModel && existingVector.embeddingModel !== currentModel) {\n  return {\n    json: {\n      shouldSync: true,\n      reason: 'Embedding model changed',\n      kbItem: kbItem,\n      needsEmbedding: true\n    }\n  };\n}\n\n// Item is up to date - skip sync\nreturn {\n  json: {\n    shouldSync: false,\n    reason: 'Item already synced and up to date',\n    kbItem: kbItem,\n    existingVector: existingVector\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [240, 80],
      "id": "check-sync-needed",
      "name": "Check If Sync Needed"
    },
    {
      "parameters": {
        "operation": "findOne",
        "collection": "knowledge_base_vectors",
        "filter": {
          "_id": "={{ $('Parse Input').first().json.kbItemId }}"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.mongodb",
      "typeVersion": 1.2,
      "position": [240, -80],
      "id": "check-existing-vector",
      "name": "Check Existing Vector",
      "credentials": {
        "mongoDb": {
          "id": "mongodb-credentials",
          "name": "MongoDB Vector DB"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-1",
              "leftValue": "={{ $json.shouldSync }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [480, 80],
      "id": "should-sync-check",
      "name": "Should Sync?"
    },
    {
      "parameters": {
        "jsCode": "// Extract text content from rich text for embedding\nconst checkResult = $('Check If Sync Needed').first().json;\nconst kbItem = checkResult.kbItem;\n\n// Convert rich text to plain text\nfunction extractTextFromRichText(richText) {\n  if (!richText || !richText.root) return '';\n  \n  function traverse(node) {\n    if (typeof node === 'string') return node;\n    if (node.text) return node.text;\n    if (Array.isArray(node.children)) {\n      return node.children.map(traverse).join(' ');\n    }\n    if (node.children && typeof node.children === 'object') {\n      return traverse(node.children);\n    }\n    return '';\n  }\n  \n  return traverse(richText.root).trim();\n}\n\nconst title = kbItem.title_de || '';\nconst contentText = extractTextFromRichText(kbItem.content_de);\nconst combinedText = `${title}\\n\\n${contentText}`.trim();\n\n// Extract tags\nconst tags = (kbItem.tags || []).map(t => t.tag || t).filter(Boolean);\n\n// Create content hash for tracking\nfunction createContentHash(item) {\n  const title = item.title_de || '';\n  const content = JSON.stringify(item.content_de || {});\n  const tags = JSON.stringify((item.tags || []).map(t => t.tag || t).sort());\n  const category = item.category || '';\n  return `${title}|${content}|${tags}|${category}`;\n}\n\nreturn {\n  json: {\n    kbItemId: kbItem.id,\n    title_de: title,\n    contentText: contentText,\n    combinedText: combinedText,\n    tags: tags,\n    category: kbItem.category || null,\n    status: kbItem.status,\n    contentHash: createContentHash(kbItem),\n    reason: checkResult.reason\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [720, 80],
      "id": "prepare-text",
      "name": "Prepare Text for Embedding"
    },
    {
      "parameters": {
        "resource": "embedding",
        "operation": "create",
        "model": "={{ $env.EMBEDDING_MODEL || 'text-embedding-3-small' }}",
        "input": "={{ $json.combinedText }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1,
      "position": [960, 80],
      "id": "generate-embedding",
      "name": "Generate Embedding",
      "credentials": {
        "openAiApi": {
          "id": "openai-credentials",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Prepare document for MongoDB upsert\nconst textData = $('Prepare Text for Embedding').first().json;\nconst embeddingResult = $input.first().json;\n\n// Extract embedding array\nconst embeddingArray = Array.isArray(embeddingResult.embedding) \n  ? embeddingResult.embedding \n  : (embeddingResult.data || []);\n\nif (!Array.isArray(embeddingArray) || embeddingArray.length === 0) {\n  throw new Error('Failed to generate embedding: Invalid embedding array');\n}\n\nconst embeddingModel = $env.EMBEDDING_MODEL || 'text-embedding-3-small';\nconst now = new Date().toISOString();\n\nconst document = {\n  _id: textData.kbItemId,\n  title_de: textData.title_de,\n  content_de: textData.contentText,\n  contentHash: textData.contentHash,\n  tags: textData.tags,\n  category: textData.category,\n  status: textData.status,\n  embedding: embeddingArray,\n  embeddingModel: embeddingModel,\n  embeddingDimensions: embeddingArray.length,\n  lastSyncedAt: now,\n  createdAt: now,\n  updatedAt: now\n};\n\nreturn { json: document };"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 80],
      "id": "prepare-document",
      "name": "Prepare Document"
    },
    {
      "parameters": {
        "operation": "upsert",
        "collection": "knowledge_base_vectors",
        "filter": {
          "_id": "={{ $json._id }}"
        },
        "updateFields": {
          "fields": [
            {
              "fieldName": "title_de",
              "fieldValue": "={{ $json.title_de }}"
            },
            {
              "fieldName": "content_de",
              "fieldValue": "={{ $json.content_de }}"
            },
            {
              "fieldName": "contentHash",
              "fieldValue": "={{ $json.contentHash }}"
            },
            {
              "fieldName": "tags",
              "fieldValue": "={{ $json.tags }}"
            },
            {
              "fieldName": "category",
              "fieldValue": "={{ $json.category }}"
            },
            {
              "fieldName": "status",
              "fieldValue": "={{ $json.status }}"
            },
            {
              "fieldName": "embedding",
              "fieldValue": "={{ $json.embedding }}"
            },
            {
              "fieldName": "embeddingModel",
              "fieldValue": "={{ $json.embeddingModel }}"
            },
            {
              "fieldName": "embeddingDimensions",
              "fieldValue": "={{ $json.embeddingDimensions }}"
            },
            {
              "fieldName": "lastSyncedAt",
              "fieldValue": "={{ $json.lastSyncedAt }}"
            },
            {
              "fieldName": "updatedAt",
              "fieldValue": "={{ $json.updatedAt }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.mongodb",
      "typeVersion": 1.2,
      "position": [1440, 80],
      "id": "upsert-vector",
      "name": "Upsert to Vector DB",
      "credentials": {
        "mongoDb": {
          "id": "mongodb-credentials",
          "name": "MongoDB Vector DB"
        }
      }
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "={{ $env.PAYLOAD_API_URL }}/api/knowledge-base-items/{{ $('Parse Input').first().json.kbItemId }}/embedding-metadata",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{ $env.PAYLOAD_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={\n  \"embeddingMetadata\": {\n    \"embedding_id\": \"{{ $json._id }}\",\n    \"model\": \"{{ $json.embeddingModel }}\",\n    \"dimensions\": {{ $json.embeddingDimensions }},\n    \"last_synced\": \"{{ $json.lastSyncedAt }}\"\n  }\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1680, 80],
      "id": "update-metadata",
      "name": "Update Embedding Metadata"
    },
    {
      "parameters": {
        "jsCode": "// Format success response\nconst parseInput = $('Parse Input').first().json;\nconst checkResult = $('Check If Sync Needed').first()?.json || {};\nconst document = $('Prepare Document').first()?.json || {};\n\nif (parseInput.action === 'delete') {\n  return {\n    json: {\n      success: true,\n      action: 'delete',\n      kbItemId: parseInput.kbItemId,\n      message: 'Item deleted from vector database'\n    }\n  };\n}\n\nif (!checkResult.shouldSync) {\n  return {\n    json: {\n      success: true,\n      action: 'skip',\n      kbItemId: parseInput.kbItemId,\n      reason: checkResult.reason || 'Item already synced and up to date',\n      message: 'Sync skipped - no changes detected'\n    }\n  };\n}\n\nreturn {\n  json: {\n    success: true,\n    action: parseInput.action,\n    kbItemId: parseInput.kbItemId,\n    embeddingDimensions: document.embeddingDimensions,\n    embeddingModel: document.embeddingModel,\n    lastSyncedAt: document.lastSyncedAt,\n    message: 'Item successfully synced to vector database'\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1920, -80],
      "id": "format-response",
      "name": "Format Response"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [[{ "node": "Parse Input", "type": "main", "index": 0 }]]
    },
    "Parse Input": {
      "main": [[{ "node": "Check Action", "type": "main", "index": 0 }]]
    },
    "Check Action": {
      "main": [
        [
          {
            "node": "Delete from Vector DB",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Fetch KB Item from Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch KB Item from Payload": {
      "main": [
        [
          {
            "node": "Check Existing Vector",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Existing Vector": {
      "main": [
        [
          {
            "node": "Check If Sync Needed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check If Sync Needed": {
      "main": [[{ "node": "Should Sync?", "type": "main", "index": 0 }]]
    },
    "Should Sync?": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Text for Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Text for Embedding": {
      "main": [[{ "node": "Generate Embedding", "type": "main", "index": 0 }]]
    },
    "Generate Embedding": {
      "main": [[{ "node": "Prepare Document", "type": "main", "index": 0 }]]
    },
    "Prepare Document": {
      "main": [[{ "node": "Upsert to Vector DB", "type": "main", "index": 0 }]]
    },
    "Upsert to Vector DB": {
      "main": [[{ "node": "Update Embedding Metadata", "type": "main", "index": 0 }]]
    },
    "Update Embedding Metadata": {
      "main": [[{ "node": "Respond to Webhook", "type": "main", "index": 0 }]]
    },
    "Delete from Vector DB": {
      "main": [[{ "node": "Format Response", "type": "main", "index": 0 }]]
    },
    "Format Response": {
      "main": [[{ "node": "Respond to Webhook", "type": "main", "index": 0 }]]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "kb-sync-v2",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "KB_SYNC_WORKFLOW",
  "tags": []
}
