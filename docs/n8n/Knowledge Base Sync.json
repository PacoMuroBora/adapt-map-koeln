{
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "kb/sync",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -512,
        224
      ],
      "id": "ebc92c08-6b46-4381-a69a-91e0ab9f0a7d",
      "name": "Webhook",
      "webhookId": "kb-sync-webhook-id"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        2944,
        288
      ],
      "id": "b9955fd5-177b-47df-b857-c5c3b49f9042",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "jsCode": "// Parse and validate webhook input\nconst webhookData = $input.first().json;\nconst body = webhookData.body || webhookData;\n\n// Validate input\nif (!body.action || !['create', 'update', 'delete'].includes(body.action)) {\n  throw new Error('Invalid action. Must be create, update, or delete');\n}\n\nif (!body.kbItemId) {\n  throw new Error('Missing kbItemId');\n}\n\n// Return formatted data\nreturn {\n  json: {\n    action: body.action,\n    kbItemId: body.kbItemId,\n    trigger: body.trigger || 'webhook'\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -272,
        224
      ],
      "id": "195ce252-aae3-4363-b4b7-449b4a1c886b",
      "name": "Parse Input"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "condition-1",
              "leftValue": "={{ $json.action }}",
              "rightValue": "delete",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        128,
        224
      ],
      "id": "18b7757c-e0d4-4e48-9436-2f41ed9f3901",
      "name": "Check Action"
    },
    {
      "parameters": {
        "url": "=https://adaptmap.de/api/knowledge-base-items/{{ $('Parse Input').first().json.kbItemId }}/api-key",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        400,
        272
      ],
      "id": "9a798178-31ef-4c7a-b481-3b83cc05976f",
      "name": "Fetch KB Item from Payload",
      "credentials": {
        "httpHeaderAuth": {
          "id": "JykOcgXjIHhsyyC1",
          "name": "Payload API key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Check if item should be synced\nconst kbItem = $input.first().json;\n\n// Only sync published items\nif (kbItem.status !== 'published') {\n  return {\n    json: {\n      shouldSync: false,\n      reason: 'Item is not published',\n      kbItem: kbItem\n    }\n  };\n}\n\n// Check if item exists in MongoDB\nconst existingVector = $('Check Existing Vector').first()?.json || null;\n\nif (!existingVector) {\n  // Item doesn't exist - needs sync\n  return {\n    json: {\n      shouldSync: true,\n      reason: 'Item not found in vector DB',\n      kbItem: kbItem,\n      needsEmbedding: true\n    }\n  };\n}\n\n// Item exists - check if content changed\n// Create content hash for comparison\nfunction createContentHash(item) {\n  // Extract company or tip for title\n  const title = item.companyOrTip?.company || item.companyOrTip?.tip || '';\n  // Combine all text content fields\n  const description = item.description || '';\n  const problemsSolved = item.problems_solved || '';\n  const applicableWhen = item.applicable_when || '';\n  const content = `${description}|${problemsSolved}|${applicableWhen}`;\n  // Extract categories and keywords\n  const categories = JSON.stringify((item.categories || []).sort());\n  const keywords = JSON.stringify((item.keywords || []).map(k => k.keyword || k).sort());\n  return `${title}|${content}|${categories}|${keywords}`;\n}\n\nconst currentHash = createContentHash(kbItem);\nconst existingHash = createContentHash(existingVector);\n\nif (currentHash !== existingHash) {\n  // Content changed - needs sync\n  return {\n    json: {\n      shouldSync: true,\n      reason: 'Content changed',\n      kbItem: kbItem,\n      needsEmbedding: true\n    }\n  };\n}\n\n// Check if embedding model changed\nconst currentModel = $env.EMBEDDING_MODEL || 'text-embedding-3-small';\nif (existingVector.embeddingModel && existingVector.embeddingModel !== currentModel) {\n  return {\n    json: {\n      shouldSync: true,\n      reason: 'Embedding model changed',\n      kbItem: kbItem,\n      needsEmbedding: true\n    }\n  };\n}\n\n// Item is up to date - skip sync\nreturn {\n  json: {\n    shouldSync: false,\n    reason: 'Item already synced and up to date',\n    kbItem: kbItem,\n    existingVector: existingVector\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1024,
        272
      ],
      "id": "8bcaba3b-cfab-498a-9dc0-ea6325aa62e1",
      "name": "Check If Sync Needed"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "condition-1",
              "leftValue": "={{ $json.shouldSync }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1264,
        272
      ],
      "id": "4c3458f1-3fcc-4c3d-9415-ad4f97555def",
      "name": "Should Sync?"
    },
    {
      "parameters": {
        "jsCode": "// Extract text content for embedding\n// Get KB item from Check If Sync Needed node\nconst checkResult = $('Check If Sync Needed').first().json;\nconst kbItem = checkResult.kbItem;\n\nif (!kbItem || !kbItem.id) {\n  throw new Error('KB item not found in check result');\n}\n\n// Extract company or tip for title\nconst title = kbItem.companyOrTip?.company || kbItem.companyOrTip?.tip || '';\n\n// Combine all text content fields for embedding\nconst description = kbItem.description || '';\nconst problemsSolved = kbItem.problems_solved || '';\nconst applicableWhen = kbItem.applicable_when || '';\nconst additionalContext = kbItem.additional_context || '';\nconst useCase = kbItem.use_case || '';\nconst theme = kbItem.theme || '';\nconst solutionType = kbItem.solution_type || '';\nconst location = kbItem.location || '';\n\n// Build content text with all relevant fields\nconst contentParts = [];\nif (description) contentParts.push(description);\nif (problemsSolved) contentParts.push(`Problems solved: ${problemsSolved}`);\nif (applicableWhen) contentParts.push(`Applicable when: ${applicableWhen}`);\nif (additionalContext) contentParts.push(`Additional context: ${additionalContext}`);\nif (useCase) contentParts.push(`Use case: ${useCase}`);\nif (theme) contentParts.push(`Theme: ${theme}`);\nif (solutionType) contentParts.push(`Solution type: ${solutionType}`);\nif (location) contentParts.push(`Location: ${location}`);\n\nconst contentText = contentParts.join('\\n\\n').trim();\nconst combinedText = title ? `${title}\\n\\n${contentText}`.trim() : contentText;\n\n// Extract categories and keywords\nconst categories = Array.isArray(kbItem.categories) \n  ? kbItem.categories.filter(Boolean)\n  : [];\n\nconst keywords = Array.isArray(kbItem.keywords)\n  ? kbItem.keywords.map(k => {\n      // Handle both object format { keyword: '...' } and string format\n      if (typeof k === 'string') return k;\n      if (k && typeof k === 'object' && k.keyword) return k.keyword;\n      return String(k);\n    }).filter(Boolean)\n  : [];\n\n// Create content hash for tracking changes\n// Include all fields that affect the embedding\nfunction createContentHash(item) {\n  const title = item.companyOrTip?.company || item.companyOrTip?.tip || '';\n  const description = item.description || '';\n  const problemsSolved = item.problems_solved || '';\n  const applicableWhen = item.applicable_when || '';\n  const additionalContext = item.additional_context || '';\n  const useCase = item.use_case || '';\n  const theme = item.theme || '';\n  const solutionType = item.solution_type || '';\n  \n  const content = `${description}|${problemsSolved}|${applicableWhen}|${additionalContext}|${useCase}|${theme}|${solutionType}`;\n  \n  const categories = Array.isArray(item.categories) \n    ? JSON.stringify(item.categories.sort())\n    : '[]';\n  \n  const keywords = Array.isArray(item.keywords)\n    ? JSON.stringify(item.keywords.map(k => {\n        if (typeof k === 'string') return k;\n        if (k && typeof k === 'object' && k.keyword) return k.keyword;\n        return String(k);\n      }).sort())\n    : '[]';\n  \n  return `${title}|${content}|${categories}|${keywords}`;\n}\n\nreturn {\n  json: {\n    kbItemId: String(kbItem.id),\n    title: title,\n    contentText: contentText,\n    combinedText: combinedText,\n    categories: categories,\n    keywords: keywords,\n    contentHash: createContentHash(kbItem),\n    // Include metadata for reference\n    theme: theme,\n    solutionType: solutionType,\n    location: location\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1744,
        512
      ],
      "id": "28492006-7eed-44a4-82b0-024ca9638636",
      "name": "Prepare Text for Embedding"
    },
    {
      "parameters": {
        "jsCode": "// Prepare document for MongoDB upsert\nconst textData = $('Prepare Text for Embedding').first().json;\nconst embeddingResult = $input.all();\n\nif (!Array.isArray(embeddingResult) || embeddingResult.length === 0) {\n  throw new Error('Failed to generate embedding: Invalid embedding array');\n}\n\nconst embeddingModel = $env.EMBEDDING_MODEL || 'text-embedding-3-small';\nconst now = new Date().toISOString();\n\nconst document = {\n  _id: textData.kbItemId,\n  title: textData.title,\n  contentText: textData.contentText,\n  combinedText: textData.combinedText,\n  contentHash: textData.contentHash,\n  categories: textData.categories,\n  keywords: textData.keywords,\n  embedding: embeddingResult,\n  embeddingModel: embeddingModel,\n  embeddingDimensions: embeddingResult.length,\n  lastSyncedAt: now,\n  createdAt: now,\n  updatedAt: now\n};\n\nreturn { json: document };"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2288,
        512
      ],
      "id": "51ac5d20-7ae7-4dad-818d-961900542c72",
      "name": "Prepare Document"
    },
    {
      "parameters": {
        "jsCode": "// Format success response with embedding metadata\nconst parseInput = $('Parse Input').first().json;\nconst checkResult = $('Check If Sync Needed').first()?.json || {};\nconst document = $('Prepare Document').first()?.json || {};\n\nif (parseInput.action === 'delete') {\n  return {\n    json: {\n      success: true,\n      action: 'delete',\n      kbItemId: parseInput.kbItemId,\n      message: 'Item deleted from vector database'\n    }\n  };\n}\n\nif (!checkResult.shouldSync) {\n  return {\n    json: {\n      success: true,\n      action: 'skip',\n      kbItemId: parseInput.kbItemId,\n      reason: checkResult.reason || 'Item already synced and up to date',\n      message: 'Sync skipped - no changes detected'\n    }\n  };\n}\n\n// Include embedding metadata in response for Payload to update\nreturn {\n  json: {\n    success: true,\n    action: parseInput.action,\n    kbItemId: parseInput.kbItemId,\n    embeddingMetadata: {\n      embedding_id: document._id || document.kbItemId,\n      model: document.embeddingModel || 'text-embedding-3-small',\n      dimensions: document.embeddingDimensions || 0,\n      last_synced: document.lastSyncedAt || new Date().toISOString()\n    },\n    message: 'Item successfully synced to vector database'\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2128,
        288
      ],
      "id": "caf4391b-35db-48fa-b224-5af9192f9ce9",
      "name": "Format Response"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1.2,
      "position": [
        1808,
        800
      ],
      "id": "6986aa3e-1e57-4618-9ad0-4f82262843cc",
      "name": "Embeddings OpenAI",
      "credentials": {
        "openAiApi": {
          "id": "wd5o4STXpbfsVMky",
          "name": "Temporal Key (they should get their own)"
        }
      }
    },
    {
      "parameters": {
        "mode": "insert",
        "mongoCollection": {
          "__rl": true,
          "value": "knowledge_base_vectors",
          "mode": "name"
        },
        "vectorIndexName": "vector_index",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStoreMongoDBAtlas",
      "typeVersion": 1.3,
      "position": [
        1936,
        512
      ],
      "id": "b89530a9-5ac7-47f2-b887-703eb288f845",
      "name": "MongoDB Atlas Vector Store",
      "credentials": {
        "mongoDb": {
          "id": "QTke3XRCEMPQX33d",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsonMode": "expressionData",
        "jsonData": "={{ $json }}",
        "textSplittingMode": "custom",
        "options": {
          "metadata": {
            "metadataValues": [
              {
                "name": "kbItemId",
                "value": "={{ $json.kbItemId }}"
              }
            ]
          }
        }
      },
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1.1,
      "position": [
        2016,
        800
      ],
      "id": "e4e30a32-bcd6-4118-a0af-a077af133430",
      "name": "Default Data Loader"
    },
    {
      "parameters": {
        "chunkOverlap": 200
      },
      "type": "@n8n/n8n-nodes-langchain.textSplitterTokenSplitter",
      "typeVersion": 1,
      "position": [
        2064,
        960
      ],
      "id": "7afe840f-0468-42c4-958b-ad358d656ba3",
      "name": "Token Splitter"
    },
    {
      "parameters": {
        "jsCode": "// Check if document exists in MongoDB\nconst { MongoClient } = require('mongodb');\n\n// Use your existing MongoDB connection string\nconst uri = \"mongodb+srv://adaptmap_vectors:PrnHyJbzerW953Tn@cluster0.hrerykt.mongodb.net/adaptmap_vectors?appName=Cluster0\" // $env.VECTOR_DATABASE_URI || $env.DATABASE_URI; // TODO set uri from env\n\nif (!uri) {\n  throw new Error('VECTOR_DATABASE_URI or DATABASE_URI environment variable not set');\n}\n\nconst client = new MongoClient(uri);\n\nasync function checkExisting() {\n  try {\n    await client.connect();\n    const db = client.db('adaptmap_vectors'); // Your database name\n    const collection = db.collection('knowledge_base_vectors');\n    \n    const kbItemId = $('Parse Input').first().json.kbItemId;\n    const existing = await collection.findOne({ _id: kbItemId });\n    \n    return {\n      json: existing || null\n    };\n  } catch (error) {\n    throw new Error(`Failed to check existing vector: ${error.message}`);\n  } finally {\n    await client.close();\n  }\n}\n\nreturn checkExisting();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        656,
        464
      ],
      "id": "b8d07486-3cc6-4983-a621-74f1f4ae8420",
      "name": "Check Existing Vector"
    },
    {
      "parameters": {
        "jsCode": "// Delete document from MongoDB\nconst { MongoClient } = require('mongodb');\n\nconst uri = process.env.VECTOR_DATABASE_URI || process.env.DATABASE_URI;\n\nif (!uri) {\n  throw new Error('VECTOR_DATABASE_URI or DATABASE_URI environment variable not set');\n}\n\nconst client = new MongoClient(uri);\n\nasync function deleteVector() {\n  try {\n    await client.connect();\n    const db = client.db('adaptmap_vectors');\n    const collection = db.collection('knowledge_base_vectors');\n    \n    const kbItemId = $('Parse Input').first().json.kbItemId;\n    const result = await collection.deleteOne({ _id: kbItemId });\n    \n    return {\n      json: {\n        deleted: result.deletedCount > 0,\n        kbItemId: kbItemId,\n        deletedCount: result.deletedCount\n      }\n    };\n  } catch (error) {\n    throw new Error(`Failed to delete vector: ${error.message}`);\n  } finally {\n    await client.close();\n  }\n}\n\nreturn deleteVector();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        592,
        16
      ],
      "id": "be328a33-c62c-4bea-9367-e4eae053b4db",
      "name": "Delete Vector"
    },
    {
      "parameters": {
        "jsCode": "// Delete document from MongoDB\nconst { MongoClient } = require('mongodb');\n\nconst uri = \"mongodb+srv://adaptmap_vectors:PrnHyJbzerW953Tn@cluster0.hrerykt.mongodb.net/adaptmap_vectors?appName=Cluster0\" // process.env.VECTOR_DATABASE_URI || process.env.DATABASE_URI; // TODO set uri from env\n\nif (!uri) {\n  throw new Error('VECTOR_DATABASE_URI or DATABASE_URI environment variable not set');\n}\n\nconst client = new MongoClient(uri);\n\nasync function deleteVector() {\n  try {\n    await client.connect();\n    const db = client.db('adaptmap_vectors');\n    const collection = db.collection('knowledge_base_vectors');\n    \n    const kbItemId = $('Parse Input').first().json.kbItemId;\n    const result = await collection.deleteOne({ _id: kbItemId });\n    \n    return {\n      json: {\n        deleted: result.deletedCount > 0,\n        kbItemId: kbItemId,\n        deletedCount: result.deletedCount\n      }\n    };\n  } catch (error) {\n    throw new Error(`Failed to delete vector: ${error.message}`);\n  } finally {\n    await client.close();\n  }\n}\n\nreturn deleteVector();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1536,
        512
      ],
      "id": "4dff2bf0-5b0b-4567-8ea2-fffd9c54e754",
      "name": "Delete Before Embedding"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        816,
        272
      ],
      "id": "584694e7-7188-4a9a-b91b-854a76811e80",
      "name": "Merge"
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Parse Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Input": {
      "main": [
        [
          {
            "node": "Check Action",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Action": {
      "main": [
        [
          {
            "node": "Delete Vector",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Fetch KB Item from Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch KB Item from Payload": {
      "main": [
        [
          {
            "node": "Check Existing Vector",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check If Sync Needed": {
      "main": [
        [
          {
            "node": "Should Sync?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Should Sync?": {
      "main": [
        [
          {
            "node": "Delete Before Embedding",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Text for Embedding": {
      "main": [
        [
          {
            "node": "MongoDB Atlas Vector Store",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Document": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings OpenAI": {
      "ai_embedding": [
        [
          {
            "node": "MongoDB Atlas Vector Store",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "MongoDB Atlas Vector Store": {
      "main": [
        [
          {
            "node": "Prepare Document",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Default Data Loader": {
      "ai_document": [
        [
          {
            "node": "MongoDB Atlas Vector Store",
            "type": "ai_document",
            "index": 0
          }
        ]
      ]
    },
    "Token Splitter": {
      "ai_textSplitter": [
        [
          {
            "node": "Default Data Loader",
            "type": "ai_textSplitter",
            "index": 0
          }
        ]
      ]
    },
    "Check Existing Vector": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Delete Vector": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Before Embedding": {
      "main": [
        [
          {
            "node": "Prepare Text for Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Check If Sync Needed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "instanceId": "b32eea9df48850b6574f57ade3758b33ead212ef1b948eeb63b86f46c7850224"
  }
}